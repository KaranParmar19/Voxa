=============================================================================
                          VOXA - PROJECT VIVA GUIDE
=============================================================================
Project Title: VOXA - Real-Time Collaborative Workspace
Features: Whiteboard, Code Editor, AI Diagram Generator, Chat, Voice Room
=============================================================================


-----------------------------------------------------------------------------
1. FULL SYSTEM ARCHITECTURE OVERVIEW
-----------------------------------------------------------------------------
VOXA follows a modern Client-Server / Publish-Subscribe architecture:
Client (Frontend): React.js SPA (Single Page Application) that manages the UI, Canvas rendering, and local state. Connects to the server via HTTP for REST APIs and WebSocket for real-time data.
Server (Backend): Node.js + Express.js server acting as the central nervous system. It handles authentication, database queries, and runs the Socket.IO server to broadcast real-time events to connected clients.
Database: MongoDB (NoSQL) for storing persistent data like user profiles, room configurations, chat history, and saved canvas states.
Real-Time Layer: Socket.IO for broadcasting coordinates and chat messages. WebRTC for peer-to-peer audio streaming.
AI Layer: Integrated LLM (e.g., OpenAI/Gemini) to parse user text prompts and generate Mermaid.js diagram code, which the frontend renders.


-----------------------------------------------------------------------------
2. COMPLETE TECHNOLOGY STACK
-----------------------------------------------------------------------------

A. FRONTEND
Technology Name: React.js
- Category: Frontend UI Library
- Why it was used: React's component-based architecture is perfect for building complex interactive UIs like a whiteboard + code editor where different panels need to update independently without reloading the page.
- How it works internally: Uses a Virtual DOM. When state changes (e.g., a user types code or draws), React updates the Virtual DOM, calculates the minimal differences (diffing), and efficiently updates the real browser DOM.
- What problem it solves: Prevents slow, full-page reloads and makes state management and UI state synchronization predictable.
- How it integrates: Connects to the Express backend via Axios (HTTP) and Socket.IO-client.
- Role in real-time collab: Triggers re-renders instantly when Socket.IO receives new data from remote users, showing their cursors or drawings.

Technology Name: Fabric.js
- Category: HTML5 Canvas Library
- Why it was used: Raw HTML5 canvas is difficult to manage when dealing with distinct objects (shapes, text). Fabric.js provides an Object Model on top of the canvas.
- How it works internally: It wraps the native canvas API and maintains a state tree of objects (rectangles, paths, text). When modified, it redraws the canvas efficiently. Allows serialization (saving canvas to JSON/SVG).
- What problem it solves: Makes selecting, moving, resizing, and deleting shapes extremely easy compared to manually calculating pixels.

Technology Name: Framer Motion
- Category: Animation Library
- Why it was used: To provide a premium, modern, and fluid user experience (UI animations, transitions).

B. BACKEND
Technology Name: Node.js + Express.js
- Category: Backend Runtime & Web Framework
- Why it was used: Node.js is heavily asynchronous and event-driven, which makes it perfect for handling thousands of concurrent WebSocket connections (which VOXA heavily relies on) without blocking the thread.
- How it works internally: Uses the V8 JavaScript engine and an Event Loop to handle asynchronous operations non-blockingly.
- What problem it solves: Traditional multi-threaded servers struggle with massive concurrent connections. Node.js solves this with lightweight async I/O.
- How it integrates: Provides the REST APIs for frontend interaction and serves as the attachment point for the Socket.IO server.

C. REAL-TIME COMMUNICATION
Technology Name: Socket.IO
- Category: WebSocket Wrapper Library
- Why it was used: Native WebSockets don't have built-in fallback mechanisms or connection recovery. Socket.IO provides rooms, broadcasting, and automatic reconnects out of the box.
- How it works internally: Establishes a long-running bidirectional TCP connection between the client and server. If WebSockets fail, it falls back to HTTP long-polling.
- What problem it solves: Enables the server to push data down to clients instantly without the client asking for it (crucial for live drawing).
- Role in real-time collab: Broadcasts exact X/Y coordinates of drawings, code insertions, and chat messages to everyone in a specific "Room".

Technology Name: WebRTC (Simple-Peer)
- Category: Peer-to-Peer Communication Protocol
- Why it was used: For low-latency Voice Communication.
- How it works internally: Uses Socket.IO only initially to exchange "Signaling Data" (IP addresses and codec info). Once exchanged, the audio data flows directly from User A's browser to User B's browser, bypassing the server entirely.
- What problem it solves: Routing audio through a server adds lag and server cost. P2P WebRTC ensures ultra-low latency.

D. DATABASE
Technology Name: MongoDB
- Category: NoSQL Database
- Why it was used: Whiteboard data (shapes, lines, text) is highly dynamic and unstructured. MongoDB stores data as flexible JSON/BSON documents.
- How it works internally: Stores data in Collections and Documents rather than rigid rows and columns.
- What problem it solves: Allows us to save complex nested data (like Fabric.js canvas JSON output) effortlessly without defining strict SQL schemas.

E. AI INTEGRATION
Technology Name: LLM (OpenAI/Gemini) + Mermaid.js
- Category: Generative AI & Diagramming Tool
- Why it was used: To automate complex diagram creation (Flowcharts, ER diagrams) based on simple text descriptions.
- How it works: The user types a prompt. The Backend sends this prompt to the AI with explicit instructions to return ONLY Mermaid.js syntax. The frontend receives this syntax and passes it to the Mermaid.js library, which renders an SVG diagram on the whiteboard.


-----------------------------------------------------------------------------
3. CORE SYSTEM FEATURES EXPLAINED
-----------------------------------------------------------------------------

A. Infinite Canvas Rendering & Smart Viewport
- Concept: The whiteboard isn't actually infinite; but the user's view (viewport) can zoom in, zoom out, and pan indefinitely.
- How we built it: We use a Transformation Matrix. Panning alters the offsetX/offsetY of the canvas, and Zooming scales the coordinates. When drawing, screen coordinates are mathematically converted into virtual canvas coordinates. We also added a boundary check (Return to content button) that compares object coordinates with the current viewport limits to detect if the user gets "lost".

B. Smooth Drawing Implementation (The Pen Engine)
- Concept: Raw mouse movements produce jagged, ugly lines.
- How we built it: We process coordinates through three optimization steps:
  1. Active Overlay Layer: Drawing directly on Fabric.js is slow. We use a separate raw HTML5 canvas layered on top specifically for active drawing (zero latency).
  2. Point Thinning: We discard points that are too close to each other to save memory.
  3. Curve Smoothing: Instead of drawing straight lines between points, we calculate Quadratic BÃ©zier Curves between midpoints of the raw coordinates, creating beautifully smooth digital ink. When the mouse goes up, we convert the final path to a Fabric.js object and send it to the server.

C. Room Management & Security
- Concept: Isolated collaboration environments.
- How we built it: Rooms are generated with unique IDs. When a user joins via Socket.IO, they are placed in a 'socket.join(roomId)'. Events are emitted only to 'socket.to(roomId)', ensuring that a drawn line in Room A never appears in Room B.

D. Authentication
- Concept: Verifying user identity.
- How we built it: JSON Web Tokens (JWT). Upon login, the server issues a signed token securely stored in cookies or local storage. Every secured API request attaches this token to verify the user. We also use OAuth for robust Google Sign-In.


-----------------------------------------------------------------------------
4. DATA FLOW EXPLANATIONS (Viva QA Prep)
-----------------------------------------------------------------------------

Scenario: "Explain what happens step-by-step when a user draws a line."
Answer:
1. The user presses the mouse. React captures the `pointerdown` event on the active overlay canvas.
2. An 'interaction-start' event is sent via Socket.IO conveying the start coordinates so remote users see a cursor appear.
3. As the mouse moves (`pointermove`), the frontend calculates smoothed curves and immediately renders them on the local overlay canvas at 60fps via `requestAnimationFrame`.
4. Upon `pointerup`, the smoothed path is converted into a Fabric.js object and added to the main persistent canvas.
5. The frontend extracts the JSON representation of this new shape and emits a 'draw-data' Socket event.
6. The Node.js server receives it and broadcasts it to all other clients in that specific Room.
7. Remote clients receive the JSON, construct the Fabric.js object, and insert it onto their screens. The server concurrently saves this new state to MongoDB.

Scenario: "How does the AI Text-to-Diagram work?"
Answer:
1. User enters text like "Diagram of a login system".
2. Client sends an HTTP POST request to our Backend.
3. Backend calls the LLM API using a strict system prompt: "You are a Mermaid code generator. Output only valid Mermaid code."
4. The AI returns the code string (e.g., `graph TD; A[Login] --> B{Valid?}`).
5. Backend forwards the string to the Client.
6. Client mounts the Mermaid.js component, which parses the string into an SVG image element and places it onto the Fabric.js canvas as a draggable object.


-----------------------------------------------------------------------------
5. ADVANTAGES OF THIS STACK
-----------------------------------------------------------------------------
1. High Concurrency: Node.js + Socket.IO can handle massive amounts of real-time coordinate data without choking.
2. Single Language (JavaScript): Allows seamless data sharing (like JSON objects representing drawings) between the MongoDB database, Node server, and React frontend without heavy serialization/deserialization penalties.
3. Modularity: React components ensure that the complex whiteboard logic doesn't interfere with the code editor or the chat UI logic.
4. Scale-Readiness: Because we use Socket.IO rooms and JWT stateless authentication, the backend can easily be scaled horizontally using Redis adapters in the future.
=============================================================================
